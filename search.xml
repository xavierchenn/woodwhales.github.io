<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优秀博客集锦]]></title>
    <url>%2F2018%2F12%2F22%2F002%2F</url>
    <content type="text"><![CDATA[一、超个性化的 Hexo 博客 内含一些搭建博客教程，值得学习。 Felix reuixiy BanbanRamble 兰州小红鸡 刘志进实验室 ChungZH’s Blog asdfv1929 ‘s Home loremwalker 偶发现 asdfv1929 ‘s Home 二、Hexo 主题及插件 melody主题 Hexo 标签云插件 三、Java 博客 高质量博文。 Jacksgong/Blog 猴子007 三、其他技术博客 高质量博文。 IT范儿 DongSheng’s Blog jin-yang 嗜血星空earth ETRD博客 Never_yu’s blog 四、信息资源 Fadeer的日志 五、hexo搭建 颜色搭配：materialpalette 渐变色搭配： shapefactory webgradients coolhue 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 Hexo NexT主题内加入动态背景 hexo的next主题个性化配置教程 SVG 参考手册 编写 SVG 的指南 SVG学习笔录（一） 高手在民间，欢迎补充。]]></content>
      <categories>
        <category>干货推荐</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程的艺术 | 学习笔记（二）]]></title>
    <url>%2F2018%2F12%2F20%2F004%2F</url>
    <content type="text"><![CDATA[第2章 Java 并发机制的底层实现原理Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，JVM 再将字节码翻译转化为汇编指令，使其在 CPU 上执行。 Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。本章将深入底层一起探索下 Java 并发机制的底层实现原理。 Java 虚拟机规范官方文档 一、volatile 的应用在多线程并发编程中 synchronized 和 volatile 都扮演着重要的角色，volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的”可见性”。 可见性就是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。本文将深入分析在硬件层面上 Intel 处理器是如何实现 volatile 的，通过深入分析帮助我们正确地使用 volatile 变量。 移步阅读笔者之前写过的学习笔记： 细说Java多线程之内存可见性：学习笔记（一） 细说Java多线程之内存可见性：学习笔记（二） 1.1 volatile 的定义与实现原理1.1.1 volatile 定义Java 语言规范第 3 版中对 volatile 的定义如下：Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。因此 Java 语言提供了 volatile，在某些情况下比 synchronized 锁要更加方便。如果一个字段被声明成 volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的。 从上述描述中可知：volatile 可以保证共享变量的可见性，并没有保证原子性。 CPU 术语说明： volatile 保证线程的可见性，在 JVM 的底层中一定使用到了 CPU 操作指令，因此有必要先了解一下 CPU 中的一些基础术语： 内存屏障（memory barriers）是一组处理器指令，用于实现对内存操作的顺序限制。 缓冲行（cache line）缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存的读周期。 原子操作（atomic operations）不可中断的一个或一系列操作。 缓冲行填充（cache line fill）当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3 的或所有）。 缓冲命中（cache hit）如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取。 写命中（write hit）当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被成为写命中。 写缺失（write misses the cache）一个有效的缓存行被写入到不存在的内存区域。 1.1.2 volatile 的实现原理如果对声明了 volatile 的共享变量进行写操作时，JVM 就会向处理器发送一条 Lock 前缀的指令（JVM 翻译转化成的汇编指令），目的就是将这个变量所在缓存行的数据写回到系统内存。 当某个线程写完自己工作内存的操作数，并通过 JVM 携带的 Lock 前缀指令告知当前写完的操作数要及时更新到系统内存。 仅仅这一步还不够，因为其他线程的工作内存中的操作数还是原来的状态，而不是当前系统内存中最新的操作数。同时处理器本身的机制决定了线程之前不能直接通信：为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。 那如何保证其他线程操作数之前能拿到最新的操作数呢？ 在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址在系统内存中被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 1.1.3 volatile 的两条实现原则 Lock 前缀指令会引起处理器缓存回写到内存 对于不同的处理器版本，Lock 前缀指令导致在执行指令期间，对声言处理器的LOCK#信号有不同的处理机制： 对于 Intel 486 和 Pentium 处理器，LOCK# 信号确保在声言该信号期间，处理器可以独占任何共享内存，因为它会锁住总线，导致其他 CPU 不能访问总线，不能访问总线就意味着不能访问系统内存。 在 P 6 和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言 LOCK# 信号。它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。 一个处理器的缓存回写到内存会导致其他处理器的缓存无效 IA-32 处理器和 Intel 64 处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。 处理器的嗅探技术： 在多核处理器系统中进行操作的时候，处理器能嗅探其他处理器访问系统内存和它们的内部缓存，以保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。 例如，在 Pentium 和 P 6 family 处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址（并且这个地址当前处于共享状态），那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。 1.1.4 volatile的使用优化在 JDK 7 的并发包里新增一个队列集合类Linked-TransferQueue，它在使用 volatile 变量时，用一种追加字节的方式来优化队列出队和入队的性能。 这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就是将共享变量追加到 64 字节。因为目前主流处理器高速缓存行是 64 个字节宽，不支持部分填充缓存行，通过追加到 64 字节的方式填满高速缓冲区的缓存行，避免各元素加载到同一缓存行而互相锁定。 并不是所有的使用 volatile 变量时都应该追加到 64 字节： 1）对于缓存行非 64 字节宽的处理器。如 P 6 系列和奔腾处理器，它们的 L1 和L2 高速缓存行是32个字节宽。 2）如果共享变量不被频繁写的话，锁的机率很小，就没必要通过追加字节的方式来避免相互锁定。因为追加字节的方式需要处理器读取更多的字节到高速缓冲区，需要更高的性能消耗。 不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。 二、synchronized 的应用synchronized 常被称为重量级锁，但是随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重了，因为有了偏向锁和轻量级锁，以及锁的存储结构和升级过程。 Java 中的每一个对象都可以作为锁。具体表现为以下 3 种形式： 对于普通同步方法，锁是当前实例对象（this）。 对于静态同步方法，锁是当前类的 Class 对象。 对于同步方法块，锁是 synchonized 括号里配置的对象。 synchonized 在 JVM 里的实现原理 从 JVM 规范中可以看到 Synchonized 在 JVM 里的实现原理：JVM 基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。 代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现（JVM 规范里并没有详细说明），但可以使用这两个指令来实现。 JVM 里的 Monitor monitorenter指令是在编译后插入到同步代码块的开始位置，monitorexit指令是插入到方法结束处和异常处。 JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。 2.2.1 Java 对象头synchronized 用的锁是存在 Java 对象头里的。Java 对象头针对数组类型对象和非数组类型对象存储的信息不同，前者存 3 个字宽（Word）的信息，后者存 2 个字宽的信息。 在不同的位数操作系统中，字宽对应的字节大小不同： 在 32 位虚拟机中，1 字宽等于 4 字节，即 32 bit 在 64 位虚拟机中，1 字宽等于 8 字节，即 64 bit 每个字宽中存储着不同的信息标识： 在 Java 对象头里的Mark Word里默认存储对象的 HashCode、分代年龄和锁标记位。32 位 JVM 的Mark Word的默认存储结构如下图所示： 在运行期间，Mark Word 里存储的数据会随着锁标志位的变化而变化，以下 4 种数据变化： 用一张图来描述上述的各种表结构之间的关系： 在 64 位虚拟机下，Mark Word 是 64 bit 大小的，其存储结构如下表： 注意：上表中偏向锁的状态的头信息中出现了线程 ID，并且偏向锁的值为 1。 三、锁的升级与对比Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了”偏向锁”和”轻量级锁”，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。 这几个状态会随着竞争情况逐渐升级，并且这种升级之后不可降级，因此偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 3.1 偏向锁大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。偏向锁在 Java 6 和 Java 7 里是默认启用的，但是它在应用程序启动几秒钟之后才激活。 3.1.1 偏向锁的初始化 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，存储之前会测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。 如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。 3.1.2 偏向锁的撤销 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。 偏向锁撤销的前提是需要等待全局安全点，即在这个时间点上没有正在执行的字节码。撤销之后的偏向锁会变成无锁状态，即具体 Mark Word 信息体中不含本线程 ID。 以下为撤销流程文字描述： 偏向锁撤销时首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 下图中的线程 1 演示了偏向锁初始化的流程，线程 2 演示了偏向锁撤销的流程。 3.1.3 偏向锁的关闭 偏向锁在 Java 6 和 Java 7 里会默认在应用程序启动几秒钟之后激活，可以使用 JVM 参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。 如果确定应用程序里所有的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。 3.2 自旋锁首先，内核态与用户态的切换上不容易优化。但通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。 线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作。同时可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。 所谓”自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于 running 状态，但是基于 JVM 的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。 自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了”忙式等待”，忙式等待显然还不如阻塞锁。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要。 JVM 对于自旋周期的选择，JDK 1.5 中这限度是一定要写死，在 JDK 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化。 3.3 轻量级锁自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此轻量级锁是相对于重量级锁而言的。 轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。 轻量级锁的加锁 线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。 如果成功，当前线程获得锁。 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 当轻量级锁使用自旋的方式获取锁仍然失败时，表示存在其他线程竞争锁（两条或两条以上的线程竞争同一个锁），则轻量级锁会膨胀成重量级锁。 轻量级锁的解锁 轻量级解锁时，会使用原子的 CAS 操作来将 Displaced Mark Word 替换回到对象头： 如果成功，则表示同步过程已完成。 如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。在释放锁的同时，唤醒被挂起的线程。 轻量锁与偏向锁不同的是： 轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁 每次进入退出同步块都需要 CAS 更新对象头 争夺轻量级锁失败时，自旋尝试抢占锁 因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。 3.4 重量级锁重量锁在 JVM 中又叫对象监视器（Monitor），它很像 C 中的Mutex，除了具备 Mutex(0|1) 互斥的功能，它还负责实现了 Semaphore （信号量）的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait 队列），前者负责做互斥，后一个用于做线程同步。 3.5 锁的优缺点的对比偏向锁 优点加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 缺点如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用场景适用于只有一个线程访问同步块场景。 轻量级锁 优点竞争的线程不会阻塞，提高了程序的响应速度。 缺点如果始终得不到锁竞争的线程使用自旋会消耗 CPU。 适用场景追求响应时间，锁占用时间很短（同步块执行速度非常快）。 重量级锁 优点线程竞争不使用自旋，不会消耗 CPU 。 缺点线程阻塞，响应时间缓慢。 适用场景追求吞吐量，同步块执行速度较长。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程的艺术 | 学习笔记（一）]]></title>
    <url>%2F2018%2F12%2F18%2F003%2F</url>
    <content type="text"><![CDATA[第一章 并发编程的挑战并发编程的目的是为了让程序运行得更快，而不是让程序最大限度的并发运行。 从上述描述中可以得知：快是终极目标，而并发只是一种达成目的的手段，因此如果一味的追求极限并发，那么会遇到很多挑战：上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。 一、上下文切换时间片 即使是单核处理器也支持多线程执行代码，CPU 通过给每个线程分配 CPU 时间片来实现这个机制。时间片是 CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。 上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 时间片分配算法中的时间片轮转调度算法是一种最古老，最简单，最公平且使用最广的算法。 基本原理： 在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则，排成一个队列,每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾。然后再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片的处理机执行时间。 从上述描述中可以得 CPU 给线程频繁分配时间片的过程中，会频繁的记录任务状态再加载任务状态，简称为上下文切换，会存在隐形的性能开销问题。 1.1 测试上下文切换次数和时长测试工具： 使用Lmbench3可以测量上下文切换的时长。下载地址：http://www.bitmover.com/lmbench/get_lmbench.html 使用vmstat可以测量上下文切换的次数。vmstat（Virtual Meomory Statistics，虚拟内存统计）是 Linux 系统中监控内存的常用工具，可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。 1.2 如何减少上下文切换减少上下文切换的方法有：无锁并发编程、CAS 算法、使用最少线程和使用协程。 无锁并发编程 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。 CAS 算法 Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。 使用最少线程 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。 协程 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。 1.3 减少上下文切换实战如果发现有大量线程处于 WAITING 状态，那么可以使用 Java 自带的jstack命令dump 出所有线程状态的统计信息，通过统计信息可以找出相应的 WAITING 线程，并将这个 WAITING 线程池的线程数减少一些，因为 WAITING 的原因正是由于上下文切换占用了 CPU 的大量资源。 二、死锁死锁模拟： 死锁模拟1234567891011121314151617181920212223242526272829303132333435public class DeadLockDemo &#123; privat static String A = "A"; private static String B = "B"; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; private void deadLock() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override publicvoid run() &#123; synchronized (A) &#123; try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (B) &#123; System.out.println("1"); &#125; &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override publicvoid run() &#123; synchronized (B) &#123; synchronized (A) &#123; System.out.println("2"); &#125; &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 线程 t1 在抓 A 锁的同时还要 B 锁，线程 tA 在抓 B 锁的同时还要 A 锁，当出现两者都抓着其中一把，等着对方把另一把锁释放时，死锁就出现了。 在一些复杂的场景中，可能会遇到上述这样类似的问题，比如 t1 拿到锁之后，因为一些异常情况没有释放锁（死循环）。又或者是 t1 拿到一个数据库锁，释放锁的时候抛出了异常，没释放掉。 一旦出现死锁，业务是可感知的，因为不能继续提供服务了，那么只能通过 dump 线程查看到底是哪个线程出现了问题。 避免死锁的几个常见方法 避免一个线程同时获取多个锁。 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。 三、资源限制1.1 什么是资源限制资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。 硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。 软件资源限制有数据库的连接数和 socket 连接数等。 使用并发编程并不会改变这些硬件资源物理限制，数据库连接数限制虽然属于软件资源，但是对于调用者来说，也是不可逾越的屏障。 1.2 资源限制带来的问题因为受到资源限制问题，导致并发编程的程序得不到充分的施展，因为当某段代码本来可以串行执行，结果改成了并发执行，由于资源限制，它们仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。 1.3 如何解决资源限制的问题对于硬件资源限制可以考虑使用集群并行执行程序。 既然单机的资源有限制，那么就让程序在多机上运行。比如使用 ODPS、Hadoop 或者自己搭建服务器集群，不同的机器处理不同的数据。 可以通过”数据 ID% 机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。 对于软件资源限制可以考虑使用资源池将资源复用。 比如使用连接池将数据库和 Socket 连接复用，或者在调用对方 webservice 接口获取数据时，只建立一个连接。 1.4 在资源限制情况下进行并发编程如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度。 比如下载文件程序依赖于两个资源：带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果 SQL 语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时任务全解]]></title>
    <url>%2F2018%2F12%2F17%2F005%2F</url>
    <content type="text"><![CDATA[在项目开发过程中，经常需要定时任务来帮助我们来做一些内容，springboot 默认已经帮我们实行了，开发者只需要添加相应的注解就可以实现。 一、Spring Task 定时任务1.1 静态定时任务（基于 @Scheduled 注解）1.1.1 pom 配置pom 包里面只需要引入springboot starter包即可： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 1.1.2 启动类启用定时在启动类上面加上@EnableScheduling即可开启定时： 1234567@EnableScheduling@SpringBootApplicationpublic class KingApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(KingApplication.class, args); &#125;&#125; 注意：这里的@EnableScheduling注解，它的作用是发现注解@Scheduled的任务并由后台执行。没有它的话将无法执行定时任务。 引用官方文档原文：@EnableScheduling ensures that a background task executor is created. Without it, nothing gets scheduled. 官方文档地址：http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#scheduling-enable-annotation-support 1.1.3 创建定时任务实现类定时任务1：每过 6 秒执行 12345678910@Componentpublic class Scheduler1Task &#123; private int count=0; @Scheduled(cron="*/6 * * * * ?") private void process()&#123; System.out.println("this is scheduler task runing "+(count++)); &#125;&#125; 定时任务2：每过 6 秒执行 注意：上一次执行完毕时间点之后 6 秒再执行，不会等待上一个定时任务执行完毕再启动下一个定时任务，不论上次定时任务执行时间是多少。 1234567891011@Componentpublic class Scheduler2Task &#123; private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss"); @Scheduled(fixedRate = 6000) public void reportCurrentTime() &#123; System.out.println("现在时间：" + dateFormat.format(new Date())); &#125;&#125; 定时任务3：每过上一个定时任务执行完毕之后的 6 秒执行 注意：上一次执行完毕时间点之后 6 秒再执行，等待上一次定时任务执行完毕之后再间隔 6 秒执行下一个定时任务。 1234567891011@Componentpublic class Scheduler3Task &#123; private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); @Scheduled(fixedRate = 6000) public void reportCurrentTime() &#123; System.out.println("现在时间：" + dateFormat.format(new Date())); &#125;&#125; 1.1.4 参数说明@Scheduled 参数可以接受两种定时的设置每隔 6 秒执行定时任务： 一种是我们常用的cron=&quot;*/6 * * * * ?&quot;，另一种是 fixedRate = 6000 fixedRate 说明 fixedRate ：上一次开始执行时间点之后再执行，参数类型为 long，单位 ms； fixedRateString：与fixedRate的含义一样，只是将参数类型变为 String； fixedDelay ：上一次执行完毕时间点之后再执行，参数类型为 long，单位 ms； fixedDelayString：与fixedDelay含义一样，只是参数类型变为 String； initialDelay ：表示延迟多久再第一次执行任务，参数类型为 long，单位 ms； initialDelayString：与initialDelay的含义一样，只是将参数类型变为 String； zone：时区，默认为当前时区，一般没有用到。 1.1.5 Cron 表达式Cron 表达式有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。 Cron 表达式是由一串字符串表示，使用数字+空格+特殊字符的形式组合成完整表达式，Cron 表达式由空格将其划分为 6 或 7 个域，每一个域代表一个含义解释： 1.1.5.1 域解释 1234567* 第一位，表示秒，取值：0-59* 第二位，表示分，取值：0-59* 第三位，表示小时，取值：0-23* 第四位，日期天/日，取值：1-31* 第五位，日期月份，取值：1-12* 第六位，星期，取值：1-7* 第七位，年份，可以留空，取值：1970-2099 注意：第六位的取值：1-7 表示的是星期一至星期日 1.1.5.2 特殊符号解释 (*)星号 可以理解为每的意思，每秒，每分，每天，每月，每年； (?)问号 只能用在每月第几天和星期两个域。表示不指定值，当 2 个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为?； (-)减号 表达一个范围，如在小时字段中使用 “10-12”，则表示从10到12点，即 10, 11, 12； (,)逗号 表达一个列表值，如在星期字段中使用 “1, 2, 4”，则表示星期一，星期二，星期四，也可以使用单词缩写来指定，例如：”MON,WED,FRI” 在星期域里表示 “星期一、星期三、星期五； (/)斜杠 表示起始时间开始触发，然后每隔固定时间触发一次，例如在分域使用 5/20 ，则意味着5分，25分，45分，分别触发一次，另外：*/y，等同于0/y； (L)字符 表示最后，只能出现在星期和每月第几天域，如果在星期域使用 1L，意味着在最后的一个星期日触发； (W)字符 表示有效工作日（周一到周五），只能出现在每月第几日域，系统将在离指定日期的最近的有效工作日触发事件。注意一点，W 的最近寻找不会跨过月份； LW : 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 (#)字符 用于确定每个月第几个星期几，只能出现在每月第几天域，例如在1#3，表示某月的第三个星期日。 官方例子： 1234567891011&quot;0 0 * * * *&quot; 表示每小时0分0秒执行一次&quot; */10 * * * * *&quot; 表示每10秒执行一次&quot;0 0 8-10 * * *&quot; 表示每天8，9，10点执行&quot;0 0/30 8-10 * * *&quot; 表示每天8点到10点，每半小时执行&quot;0 0 9-17 * * MON-FRI&quot; 表示每周一至周五，9点到17点的0分0秒执行&quot;0 0 0 25 12 ?&quot; 表示每年圣诞节（12月25日）0时0分0秒执行 1.2 动态定时任务（基于 SchedulingConfigurer 接口）为了演示效果，这里选用 Mysql 数据库保存 Cron 表达式，使用 Mybatis 框架来查询和调整定时任务的执行周期，然后观察定时任务的执行情况。当然，可以使用静态配置文件的形式配置。 1.2.1 pom 配置1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--添加Mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加MySql依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.2.2 添加数据库记录在 mysql 数据库中创建socks数据库，并创建cron数据库表： 123456789DROP DATABASE IF EXISTS `socks`;CREATE DATABASE `socks`;USE `SOCKS`;DROP TABLE IF EXISTS `cron`;CREATE TABLE `cron` ( `cron_id` varchar(30), `cron` varchar(30) );INSERT INTO `cron` VALUES ('1', '0/5 * * * * ?'); 在项目中的application.yml添加数据源： 12345spring: datasource: url: jdbc:mysql://localhost:3306/socks?useSSL=false username: root password: root 1.2.3 创建定时器数据库准备好数据之后，编写要定时执行的任务类，实现SchedulingConfigurer接口，重写configureTasks方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.text.SimpleDateFormat;import java.util.Date;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.EnableScheduling;import org.springframework.scheduling.annotation.SchedulingConfigurer;import org.springframework.scheduling.config.ScheduledTaskRegistrar;import org.springframework.scheduling.support.CronTrigger;import org.springframework.util.StringUtils;@Configuration@EnableSchedulingpublic class CompleteScheduleConfig implements SchedulingConfigurer&#123; protected final Logger logger = LoggerFactory.getLogger(this.getClass()); private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); @Mapper public interface CronMapper &#123; @Select("select cron from cron limit 1") String getCron(); &#125; @Autowired CronMapper cronMapper; /** * 执行定时任务 */ @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.addTriggerTask( //1.添加任务内容(Runnable) () -&gt; &#123; System.out.println("执行定时任务2: " + getNow()); logger.debug("执行定时任务2: " + getNow()); &#125;, //2.设置执行周期(Trigger) triggerContext -&gt; &#123; //2.1 从数据库获取执行周期 String cron = cronMapper.getCron(); //2.2 合法性校验. if (StringUtils.isEmpty(cron)) &#123; // Omitted Code .. &#125; //2.3 返回执行周期(Date) return new CronTrigger(cron).nextExecutionTime(triggerContext); &#125; ); &#125; private String getNow() &#123; return dateFormat.format(new Date()); &#125;&#125; 三、Timer 定时任务这个API目前在项目中很少用，直接给出示例代码。具体的介绍可以查看API。Timer的内部只有一个线程，如果多个任务的话就会顺序执行，这样任务的延迟时间和循环时间就会出现问题。 123456789101112131415161718192021222324252627282930import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.atomic.AtomicLong;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TimerService &#123; protected final Logger logger = LoggerFactory.getLogger(this.getClass()); private AtomicLong counter = new AtomicLong(); public void schedule() &#123; TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; long count = counter.incrementAndGet(); logger.info("Schedule timerTask &#123;&#125; times", count); &#125; &#125;; Timer timer = new Timer(); // 设置 初始化延迟时间 为 1s，定时执行间隔 为 2s timer.schedule(timerTask, 1000L, 2 * 1000L); &#125; public static void main(String[] args) &#123; TimerService timerService = new TimerService(); timerService.schedule(); &#125;&#125; 观察测试结果，能够发现TimerTask配置的任务，每隔10s被执行了一次，执行线程默认都是Timer-0这个线程，并且启动的时机是 new 出 Timer 并执行schedule()方法的时候。 12317:42:48.576 [Timer-0] INFO org.woodwhale.king.service.TimerService - Schedule timerTask 1 times17:42:50.569 [Timer-0] INFO org.woodwhale.king.service.TimerService - Schedule timerTask 2 times17:42:52.569 [Timer-0] INFO org.woodwhale.king.service.TimerService - Schedule timerTask 3 times 四、ScheduledExecutorService 定时任务ScheduledExecutorService 是 延时执行 的线程池，对于 多线程 环境下的 定时任务，推荐用 ScheduledExecutorService 代替 Timer 定时器。 4.1 等待定时任务执行完毕再进行下一次定时任务 创建一个线程数量为4的任务线程池，同一时刻并向它提交4个定时任务，用于测试延时任务的并发处理。执行ScheduledExecutorService的scheduleWithFixedDelay()方法，设置任务线程池的初始任务延迟时间为2秒，并在上一次执行完毕时间点之后2秒再执行下一次任务。 1234567891011121314151617public void scheduleWithFixedDelay() &#123; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(4); for (int i = 0; i &lt; 4; i++) &#123; scheduledExecutor.scheduleWithFixedDelay(() -&gt; &#123; // 定时任务延迟完成 2 秒 try &#123; TimeUnit.MILLISECONDS.sleep(2 * 1000L); &#125; catch (InterruptedException e) &#123; LOGGER.error("Interrupted exception", e); &#125; long count = counter.incrementAndGet(); logger.info("Schedule executor &#123;&#125; times with fixed delay", count); &#125;, 2000L, 2 * 1000L, TimeUnit.MILLISECONDS); // 初始任务延迟时间 为 2 秒，并在上一次 执行完毕时间点 之后 2 秒再执行下一次任务 &#125; logger.info("Start to schedule");&#125; 测试结果如下，我们可以发现每隔2秒的时间间隔，就会有4个定时任务同时执行。因为在任务线程池初始化时，我们同时向线程池提交了4个任务，这四个任务会完全利用线程池中的4个线程进行任务执行。 4.2 固定时间进行定时任务 创建一个线程数量为4的任务线程池，同一时刻并向它提交4个定时任务，用于测试延时任务的并发处理。每个任务分别执行ScheduledExecutorService的scheduleAtFixedRate()方法，设置任务线程池的初始任务延迟时间为2秒，并在上一次开始执行时间点之后2秒再执行下一次任务。 1234567891011public void scheduleAtFixedRate() &#123; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(4); for (int i = 0; i &lt; 4; i++) &#123; scheduledExecutor.scheduleAtFixedRate(() -&gt; &#123; long count = counter.incrementAndGet(); logger.info("Schedule executor &#123;&#125; times at fixed rate", count); &#125;, 2000L, 2 * 1000L, TimeUnit.MILLISECONDS); // 初始任务延迟时间 为 2 秒，并在上一次 执行时间开始 之后 2 秒再执行下一次任务 &#125; logger.info("Start to schedule");&#125; 测试结果如下，我们可以发现每隔 2 秒的时间间隔，就会有 4 个定时任务同时执行，因为在任务线程池初始化时，我们同时向线程池提交了 4 个任务，这 四个任务会完全利用线程池中的 4个线程进行任务执行。 五、配置任务线程池（实现多线程并发处理）上述配置都是基于单线程的任务调度，如何引入多线程提高延时任务的并发处理能力？ Spring Boot提供了一个SchedulingConfigurer配置接口。我们通过 ScheduleConfig配置文件实现ScheduleConfiguration接口，并重写 configureTasks()方法，向ScheduledTaskRegistrar注册一个ThreadPoolTaskScheduler任务线程对象即可。 12345678910111213141516171819202122232425262728293031323334import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.SchedulingConfigurer;import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;import org.springframework.scheduling.config.ScheduledTaskRegistrar;/** * 多线程执行定时任务 * 所有的定时任务都放在一个线程池中，定时任务启动时使用不同都线程。 */@Configurationpublic class ScheduleConfiguration implements SchedulingConfigurer &#123; protected final Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.setTaskScheduler(taskScheduler()); // 采用jdk 自带的执行器线程池 java.util.concurrent.Executors // taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10)); &#125; @Bean public ThreadPoolTaskScheduler taskScheduler() &#123; ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler(); taskScheduler.setPoolSize(4); //设定一个长度4的定时任务线程池 taskScheduler.setWaitForTasksToCompleteOnShutdown(true); taskScheduler.setThreadNamePrefix("schedule"); taskScheduler.setRemoveOnCancelPolicy(true); taskScheduler.setErrorHandler(t -&gt; logger.error("Error occurs", t)); return taskScheduler; &#125;&#125; 参考博文： SpringBoot 创建定时任务（配合数据库动态执行）https://www.jianshu.com/p/d160f2536de7 springboot(九)：定时任务https://www.cnblogs.com/ityouknow/p/6132645.html spring boot项目中处理Schedule定时任务https://www.rjkf.cn/springboot-schedule-cron/ SpringBoot定时任务及Cron表达式详解https://my.oschina.net/jack90john/blog/1506474 实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现https://juejin.im/post/5b31b9eff265da598826c200]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 瘦身打包]]></title>
    <url>%2F2018%2F12%2F16%2F006%2F</url>
    <content type="text"><![CDATA[在实际生产过程中，常常会遇到资源打包文件太大，在部署的时候很不方便，传统的打包方式会将所有的文件（jar 和 资源配置文件）都打包在了一个 jar 文件中，这样后期在修改配置信息的时候，相当的不方便。 因此，如何将项目本身的 jar 文件和依赖 jar 文件分离，并把资源文件也分离出来，分别独立成自己的文件目录是很有必要的。 一、传统打包方式传统的打包方式在 pom.xml 中只需要在 build 插件中配置spring-boot-maven-plugin即可： 1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 打包出来的 jar 包是下面这样的，项目生成了target文件目录，里面打包好了一个完整的 jar 文件，直接使用：java -jar king-0.0.1-SNAPSHOT.jar就能运行了。 将 jar 包解压开，会得到下面的目录结构： 注意在META-INF文件目录中存在MANIFEST.MF文件，里面记录了启动类Start-Class 、依赖类Spring-Boot-Lib等信息。 运行 jar 包的时候，首先启动的是启动类，并依赖BOOT-INF/lib/文件目录中的 jar 文件。 二、springboot 打包 lib 和资源文件分离现在有如下的打包需求： 项目自身 jar 文件打包在 zip 包根目录下，其他所有依赖包打包在lib文件夹下，资源文件全部打包在resources文件目录下，项目运行的脚本文件打包在bin文件目录下。 在pom.xml配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;build&gt; &lt;plugins&gt; &lt;!--打包jar --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--不打包资源文件 --&gt; &lt;excludes&gt; &lt;exclude&gt;bin/**&lt;/exclude&gt; &lt;exclude&gt;config/**&lt;/exclude&gt; &lt;exclude&gt;static/**&lt;/exclude&gt; &lt;exclude&gt;templates/**&lt;/exclude&gt; &lt;exclude&gt;*.yml&lt;/exclude&gt; &lt;/excludes&gt; &lt;!-- &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; // MANIFEST.MF 中 Class-Path 加入前缀，不需要配置，在外部命令行指定 &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; // jar包不包含唯一版本标识 &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt; ` // 指定入口类,如果程序里只有一个main方法就建议不要手动配置 &lt;mainClass&gt;org.woodwhale.king.KingApplication&lt;/mainClass&gt; &lt;/manifest&gt; &lt;manifestEntries&gt; // MANIFEST.MF 中 Class-Path 加入资源文件目录，不需要配置，在外部命令行指 &lt;Class-Path&gt;./resources/&lt;/Class-Path&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; --&gt; &lt;!-- 生成到 target 目录下， 也可以放到指定目录，例如： $&#123;project.build.directory&#125;/boot --&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--拷贝依赖 copy-dependencies --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!--拷贝资源文件 copy-resources --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-resources&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/resources&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- spring boot repackage， 依赖 maven-jar-plugin 打包的jar包 重新打包成 spring boot的jar包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 包含本地 jar 依赖 --&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;!-- 重写包含依赖，包含不存在的依赖，jar里没有pom里的依赖 --&gt; &lt;includes&gt; &lt;include&gt; &lt;groupId&gt;null&lt;/groupId&gt; &lt;artifactId&gt;null&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;!-- 使用外部配置文件，jar包里没有资源文件 --&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;!-- 配置jar包特殊标识 配置后，保留原文件， 生成新文件 *-run.jar 配置jar包特殊标识 不配置， 原文件命名为 *.jar.original，生成新文件 *.jar --&gt; &lt;classifier&gt;run&lt;/classifier&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 打包发布时，跳过单元测试 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 使用assembly打zip包 --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;descriptors&gt; &lt;!-- assembly配置文件位置 --&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 注意：在spring-boot-maven-plugin中配置了包含本地jar依赖的配置&lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; 在项目根目录下存在放置assembly.xml配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt; &lt;id&gt;$&#123;project.artifactId&#125;&lt;/id&gt; &lt;formats&gt; &lt;format&gt;zip&lt;/format&gt; &lt;/formats&gt; &lt;!-- 压缩包下是否生成和项目名相同的根目录 --&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;baseDirectory&gt;$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/baseDirectory&gt; &lt;fileSets&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;outputDirectory&gt;&lt;/outputDirectory&gt; &lt;includes&gt; &lt;include&gt;$&#123;artifact.artifactId&#125;-$&#123;artifact.version&#125;.jar&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;fileSet&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;outputDirectory&gt;$&#123;file.separator&#125;resources&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;fileSet&gt; &lt;directory&gt;bin/&lt;/directory&gt; &lt;outputDirectory&gt;$&#123;file.separator&#125;bin&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;fileSet&gt; &lt;directory&gt;lib/&lt;/directory&gt; &lt;outputDirectory&gt;$&#123;file.separator&#125;lib&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;/fileSets&gt; &lt;!-- 使用项目的artifact，第三方 jar 打包进zip文件的 lib 目录 --&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt; &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;includes&gt; &lt;include&gt;*:*&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;$&#123;groupId&#125;:$&#123;artifactId&#125;&lt;/exclude&gt; &lt;exclude&gt;org.springframework.boot:spring-boot-devtools&lt;/exclude&gt; &lt;/excludes&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt;&lt;/assembly&gt; 在bin脚本文件目录中放置脚本文件和配置文件： 配置文件用于指定 jar 的名称及版本信息 12ARTIFACTID=kingVERSION=0.0.1 windows 脚本start.bat文件： 1234567891011121314151617181920212223242526272829303132333435363738394041ECHO offECHO "checking config.ini..."SET ROOT=%~dp0SET CONFIG_FILE=%ROOT%config.iniREM **从配置文件中读取内容**FOR /F "tokens=1,2 delims==" %%i IN (%CONFIG_FILE%) DO ( SET %%i=%%j)SET APP_NAME=%ARTIFACTID%-%VERSION%IF "%APP_NAME%" == "" ( ECHO "this config.ini is not exist，please check this config file." GOTO End) ELSE ( ECHO "checking JAVA_HOME config from checking config.ini..." GOTO OkPath):OkPathecho "check java_home..."if not "%JAVA_HOME%" == "" GOTO OkJHome:OkJHomeif exist "%JAVA_HOME%\bin\java.exe" GOTO Runserver:RunserverSET JAR_NAME=%APP_NAME%.jarSET APP_CONFIG=-Dloader.path=.,resources,libECHO "111:%RUN_JAVA%"ECHO "Starting the %JAR_NAME%"ECHO "%JAVA_HOME%\bin\java -Xms512m -Xmx512m -jar %APP_CONFIG% %JAR_NAME%"CD ..%JAVA_HOME%\bin\java.exe -Xms512m -Xmx512m -jar %APP_CONFIG% %JAR_NAME%GOTO End:EndPAUSE 脚本解释：最为关键的就是运行jar 文件的时候携带-Dloader.path=.,resources,lib linux 脚本startup.sh文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/bin/sh## java envexport JAVA_HOME=/usr/java/jdk1.8.0_162API_NAME=./king-0.0.1.jarexport JRE_HOME=JAVA_HOME/jreAPI_CONFIG=.,resources,libJAR_NAME=$API_NAME.jarPID=$API_NAME.pidusage() &#123; echo "Usage: sh startup.sh [start|stop|restart|status]" exit 1&#125;is_exist()&#123; pid=`ps -ef|grep $JAR_NAME|grep -v grep|awk '&#123;print $2&#125;' ` if [ -z "$&#123;pid&#125;" ]; then return 1 else return 0 fi&#125;start()&#123; is_exist if [ $? -eq "0" ]; then echo "&gt;&gt;&gt; $&#123;JAR_NAME&#125; is already running PID=$&#123;pid&#125; &lt;&lt;&lt;" else nohup $JRE_HOME/bin/java -Xms256m -Xmx512m -jar -Dloader.path=$API_CONFIG $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp; echo $! &gt; $PID echo "&gt;&gt;&gt; start $JAR_NAME successed PID=$! &lt;&lt;&lt;" fi &#125;stop()&#123; #is_exist pidf=$(cat $PID) #echo "$pidf" echo "&gt;&gt;&gt; api PID = $pidf begin kill $pidf &lt;&lt;&lt;" kill $pidf rm -rf $PID sleep 2 is_exist if [ $? -eq "0" ]; then echo "&gt;&gt;&gt; api 2 PID = $pid begin kill -9 $pid &lt;&lt;&lt;" kill -9 $pid sleep 2 echo "&gt;&gt;&gt; $JAR_NAME process stopped &lt;&lt;&lt;" else echo "&gt;&gt;&gt; $&#123;JAR_NAME&#125; is not running &lt;&lt;&lt;" fi &#125;status()&#123; is_exist if [ $? -eq "0" ]; then echo "&gt;&gt;&gt; $&#123;JAR_NAME&#125; is running PID is $&#123;pid&#125; &lt;&lt;&lt;" else echo "&gt;&gt;&gt; $&#123;JAR_NAME&#125; is not running &lt;&lt;&lt;" fi&#125;restart()&#123; stop start&#125;case "$1" in "start") start ;; "stop") stop ;; "status") status ;; "restart") restart ;; *) usage ;;esacexit 0 shell 脚本里需要配置JAVA_HOME路径和 jar 文件名即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web 如何超清无码]]></title>
    <url>%2F2018%2F11%2F30%2F007%2F</url>
    <content type="text"><![CDATA[一、前言1. 文件编码格式通用设置在使用 eclipse 开发工具的时候，首先需要确定工作空间的编码格式： windows菜单 –» perferences选项 –» General选项中的Workspace工作空间选项，设置文件编码格式。 2. 文件编码格式单独设置单个项目编码格式设置：项目 –» 右键 –» Properties –» Text file encoding 单个页面文件编码格式设置：页面 –» 右键 –» Properties –» Text file encoding 一、response 响应乱码response 响应数据回浏览器之前，程序可以将数据转换成字节流的形式输出内容，也可以使用字符流的形式输出内容，但是字符流形式仅限于文本数据，因此前者在 web 开发中需要更谨慎的关注和理解原理。 1.2 字节流响应在 web 工程中创建一个简单的servlet 12345678910111213public class ResponseDemo1 extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data ="木鲸鱼"; response.getOutputStream().write(data.getBytes()); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 注意，此时的源码文件编码类型为：UTF-8，查看文件编码类型可右击文件属性，在Resource选项中的Text file encoding中可见。 servlet 资源访问路径映射配置： 123456789&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;servlet-name&gt;responseDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;org.king.response.ResponseDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;responseDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/responseDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用 IE 浏览器访问 web 工程，此时浏览器显示中文乱码，并且通过查看网页编码可知，默认使用GB2312编码解析响应文本。 为什么默认使用GB2312码表呢？因为 windows 系统本地的时区语言是中文，因此浏览器会默认使用GB2312解码响应体。当手动更改编码格式为UTF-8时，浏览器显示汉字内容正常。 那么问题来了，默认用户都是电脑小白，不能等用户看到网页乱码再自己手动修改浏览器解码格式，这似乎不是雅的 web 程序可以出现的问题。 解决方案 1：响应头设置 于是在程序响应回浏览器之前，设置响应头： 123String data ="木鲸鱼";response.setHeader("Content-Type", "text/html;charset=UTF-8"); // 增加响应头设置response.getOutputStream().write(data.getBytes()); 通过响应头的设置，使得浏览器必须以程序设置的编码格式解析 html 文本内容： 注意：在上述代码中，存在一个很隐蔽的隐患，因为源码文件就是UTF-8字符集编码的代码，并且工作空间设置的是UTF-8编码，因此在问题 1中设置浏览器为UTF-8编码解析文本的时候才能正常显示，因此对于输出字节流的时候，也就是在上述源码中对data字符串对象进行数组转换的时候指定字符集。 123String data ="木鲸鱼";response.setHeader("Content-Type", "text/html;charset=UTF-8"); // 增加响应头设置response.getOutputStream().write(data.getBytes(“UTF-8”)); 解决方案 2：模拟 http 头文件 在 html 文件中，可以使用meta标签中的http-equiv属性指定： 1234String httpHeader = "&lt;html&gt;&lt;meta http-equiv='Content-Type' content='charset=UTF-8'&gt;&lt;body&gt;"; response.getOutputStream().write(httpHeader.getBytes()); response.getOutputStream().write((data).getBytes()); response.getOutputStream().write("&lt;/body&gt;&lt;/html&gt;".getBytes()); 查看源码可知，html 解析了meta标签及其属性。另外需要注意：在 W3C 文档中说明了使用 http-equiv 已经不是规定 HTML 文档的字符集的唯一方式： HTML 4.01 与 HTML5之间的差异：HTML 4.01：&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;HTML5：&lt;meta charset=&quot;UTF-8&quot;&gt;参考地址：http://www.w3school.com.cn/tags/tag_meta.asp 1.2 字符流响应由于大多数数据都是以字符文本的形式响应回浏览器，那么可以将数据转成字符流传输。 123String data ="木鲸鱼";PrintWriter out = response.getWriter();out.write(data); 注意，即使是使用字符流传输，在网络传输过程中，均将字符数据按照一定的码表解析成机器码进行数字传输，到了目的地再通过指定的码表进行翻译解析。因此，上面简单的使用字符流数据响应回浏览器的时候一定是按照某种编码格式进行解析成二进制信息并传输的，因为项目使用的是 Tomcat 服务器，所以默认的编码格式为ISO8859-1，在 Tomcat 官方文档中的过滤器一章有这样一句说明，意思就是说，如果不指定字符集就使用 ISO8859-1传输数据： The HTTP specification is clear that if no character set is specified for media sub-types of the “text” media type, the ISO-8859-1 character set must be used.参考地址：http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html 解决方案：设置 response 字符集编码及响应头 设置 response 响应对象以特定字符集编码格式读取数据，并设置响应头，要求浏览器以特定格式解析，即可保证数据不会乱码： 12345678String data ="木鲸鱼";// 要求 response 以 UTF-8 字符集输出response.setCharacterEncoding("UTF-8");// 通知浏览器以 UTF-8 字符集解析数据// response.setHeader("Content-Type", "text/html;charset=UTF-8"); // 等效下面的代码response.setContentType("text/html;charset=UTF-8");PrintWriter out = response.getWriter();out.write(data); 注意：Java 设计者在设计HttpServletResponse对象的时候提供了setContentType()方法，它的作用就是通知浏览器以指定字符集解析文本数据，并要求 response 对象以指定字符集读取数据。 扩展： 响应头的信息中不允许包含中文编码，只能是 ASCII 码字符，那么对于图片文件需要传输文件名，就必须使用URLEncoding类对字符串进行转码： 1response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(data,"UTF-8")); 二、request 请求乱码目前，request 请求的主流请求类型为GET和POST，其中GET请求的方式，可以是在表单中提交，也可以在浏览器地址栏中显示请求。 2.1 表单中的 POST 请求post 请求数据在发送时一定经过某种字符集编码成二进制信息，再经过网络传输到服务器，post 请求在 html 页面和 jsp 页面中会有不同的表现。 [1] post 请求在html页面表现： 在 html 页面中，如果有meta信息指定字符集编码，则使用此编码传输数据，没有则使用操作系统默认编码，中文操作系统一般使用GB2312字符集编码。 下面 html 页面指定了meta信息： 123&lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; // 或者&lt;meta charset="GBK"&gt; 此时数据传输到服务器是经过UTF-8编码解析，后台获取请求数据 12String username = request.getParameter("username");String password = request.getParameter("password"); 此时一定是会出现中文乱码问题，因为在request.getParameter()的瞬间，Tomcat 会将网络数据中的二进制查询ISO8859-1字符集试图解码成可见字符并返回。 「 解决方案 」 在request.getParameter()调用之前，要求 request 对象获取请求参数的时候指定字符集： 1request.setCharacterEncoding("UTF-8"); 也就是 request 对象获取请求参数时，不要依赖服务器的 API 实现，而是使用程序员自己的字符集编码。 完美解决方案代码： 123request.setCharacterEncoding(&quot;UTF-8&quot;);String username = request.getParameter(&quot;username&quot;);String password = request.getParameter(&quot;password&quot;); [2] post 请求在 jsp 页面表现： 在 jsp 页面中，可以在@page中指定&quot;contentType&quot;，也可以在 html 文本中指定meta信息，当有@page指定charset时，此配置信息优与meta配置，就是说下面 jsp 页面在浏览器中显示的默认编码格式为GBK： 1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=GBK" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;form action="/king-world/index" method="POST"&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type="password" name="password"/&gt;&lt;br/&gt; &lt;input type="submit" value="提 交"/&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对于服务器获取参数的解决方案和在上一小结点是一致的。 2.2 表单中及地址栏中的 GET 请求页面及地址栏中的GET请求，在数据传输时使用的编码，不依赖于页面的meta或者contentType信息，GET 请求的本质是使用统一资源标志符，当表单中的GET请求发生之后，其请求地址会打印到地址栏中。 注意：在 IE 浏览器中不可以使用中文作为参数直接发请求，而 chrome 浏览器会将中文进行URL编码再发请求，至于其他浏览器是否自动转码，笔者没测试了。 GET请求由 Tomcat 服务容器接收，会将这个URL中的参数对进行ISO8859-1编码，官方文档作出了下面的解释： 在 Tomcat 系统参数配置中提到了关于URIEncoding的解释：This specifies the character encoding used to decode the URI bytes, after %xx decoding the URL. If not specified, ISO-8859-1 will be used.参考地址：https://tomcat.apache.org/tomcat-7.0-doc/config/http.html 解决方案 1 从上述描述中可知，在 Tomcat 服务器的conf配置文件目录下的server.xml中配置了连接器信息： 文件路径：%tomcat root%\conf\server.xml1&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt; 在Connector连接器中增加URIEncoding=&quot;UTF-8&quot;属性配置。 解决方案 2 在 Tomcat 的server.xml下的connector属性中添加参数useBodyEncodingForURI=&quot;true&quot;（注意，并不是对整个 URI 都采用 BodyEncoding，只是应用于 Query String 而已）。这样，Tomcat 便会用request.setCharacterEncoding()指定的编码来解析 GET 参数了。 解决方案 3 在 servlet 中手动转码，在 Tomcat 服务器中，将ISO8859-1转码成UTF-8： 1234String username = request.getParameter("username"); if(username != null &amp;&amp; !username.trim().isEmpty()) &#123; username = new String(username.getBytes("ISO8859-1"),"UTF-8");&#125; 解决方案 4 实现过滤器，对所有的请求进行拦截过滤，并在web.xml中配置filter和filter-mapping： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class EncodingFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123; // 如果希望匿名内部类使用一个在外部定义的对象，那么编译器会要求其参数引用是final的 final HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; request.setCharacterEncoding("UTF-8");// POST提交有效 response.setContentType("text/html;charset=UTF-8"); // 解决：对HttpServletRequest接口的getParameter方法进行功能扩展，识别GET请求，可以使用动态代理! HttpServletRequest proxyRequest = (HttpServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(), new Class[] &#123; HttpServletRequest.class &#125;, new InvocationHandler() &#123; // args对象数组，代表被调用方法的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); if ("getParameter".equals(methodName)) &#123; String value = request.getParameter(args[0] .toString()); String requestMethodName = request.getMethod(); if ("GET".equals(requestMethodName)) &#123; // 排除空对象及空字符串 if (value != null &amp;&amp; !"".equals(value.trim())) &#123; value = new String(value .getBytes("iso-8859-1"), "utf-8"); &#125; &#125; return value; &#125; else &#123; return method.invoke(request, args); &#125; &#125; &#125;); //放行 (执行下一个过滤器或者servlet) chain.doFilter(proxyRequest, response); &#125; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125; 推荐使用方案 4。 三、jsp 页面的编码原理3.1 jsp 页面的编码三阶段JSP要经过两次的”编码”，第一阶段会用pageEncoding，第二阶段会用UTF-8至UTF-8，第三阶段就是由 Tomcat 出来的网页， 用的是contentType。 第一阶段：JVM 将.jsp文件编译为.java文件。JVM 先读取pageEncoding的值，根据该值去读取.jsp文件，然后由指定的编码方案生成UTF-8的.java文件。 证明：在 Tomcat 服务器目录下work文件夹下的Catalina目录中找到.java文件（由jsp源码文件生成），其文件的编码是UTF-8格式，文件中的文本内容是根据pageEncoding的字符集进行记录。 第二阶段：JVM 将java文件转换为class文件，从UTF-8至UTF-8。这个过程就与任何编码的设置都没有关系了，经过这个阶段后.java文件就转换成了统一的UTF-8编码的class文件了。 第三阶段：服务器将处理的结果返回给浏览器，这个阶段则依靠contentType的charset，如果设置了charset则浏览器就会使用指定的编码格式进行解码，否则采用默认的ISO-8859-1编码格式进行解码处理。 证明：在jsp对应的.java文件源码中可以看到 response 响应已经指定了Content-Type：response.setContentType(“text/html; charset=UTF-8”); 3.2 jsp 页面中设置字符集1. pageEncoding 1&lt;%@ page pageEncoding="UTF-8"%&gt; 上文中第一阶段，使用该值去读取jsp文件，为避免中文乱码，跟jsp文件编码一致；对服务器响应进行重新编码，即jsp的输出流在浏览器中显示的编码（不是主要作用）。 2. contentType 1&lt;%@ page contentType="text/html;charset=UTF-8"%&gt; 使用该值对服务器响应进行重新编码，即jsp的输出流在浏览器中显示的编码；对表单get和post请求数据编码；上文中第一阶段，使用该值去读取jsp文件（不是主要作用）。 3. META 1&lt;META http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; 网页的编码信息 ，说明页面制作所使用的编码。 因此编写jsp页面的最佳实践是统一配置成UTF-8编码： 123&lt;%@ page contentType=”text/html;charset=UTF-8” pageEncoding="UTF-8"%&gt;…&lt; META http-equiv=”Content-Type” content=”text/html;charset=UTF-8”&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相遇即是缘分]]></title>
    <url>%2F2016%2F02%2F29%2F001%2F</url>
    <content type="text"><![CDATA[真是巧了！ 2016 年 02 月 21 日，注册微信公众号。 2018 年 12 月 21 日，发布 github 博客。 小三年的时间过去了，重温了一遍下面的文字，怎一个土字了得， 那时快要毕业了，就要步入社会自己打拼了，文字里还是透着很强的稚嫩和愤青，看着挺感慨的。 要学习的东西太多了，都来不及抒发情感了，溜了~ 2016 年 2 月 21 日晚 20：00，内心一直有一个声音在呼唤我做出一个举动 —— 注册微信公众号，这个微信公众号的功能是用来记录自己的心路历程，我看见一些个人微信公众号的文章十分专业专一，而我，一个普普通通的小人物，没有太多的专业性知识体系书写价值含量高的文章，因此我所写的文章基本上为个人文章，以前有博客，后来有微博，现在有微信，我只是用了目前最潮流的媒体形式来抒发小情绪而已，并期望通过这个微信公众号与屏幕前的你相遇。我总觉得一切的相遇都是缘分，我相信缘分也是有因果关系的，我希望自己的一点点努力和成长能帮助到身边的人，并在我们有生之年能够相互成长，共同进步！]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>编程随想</tag>
      </tags>
  </entry>
</search>
